Title         : Spring概述
Author        : Cryan
Logo          : True

[TITLE]

# Spring模块 
&emsp;Spring framework core support for dependency injection, transaction management, web applications,
data access, messaging, testing and more.

&emsp;Spring由下列模块组成

![springModule]

# Spring核心
* 依赖注入(Dependency Injection)
* 应用切面编程(Aspect-Oriented Programming including Spring's declarative transaction management)
* MVC框架(Spring MVC web application and RESTful web service framework)
* 灵活的数据支持(Foundational support for JDBC, JPA, JMS)

# Spring下的Bean
<h6>传统意义上的Java Bean满足以下条件:</h6>

* must implement either Serializable or Externalizable
* must have a no-arg constructor
* properties must have public setter and getter methods (as appropriate)
* instance variables should be private

<h6>POJO的定义满足:</h6>

* All properties must public setter and getter methods
* All instance variables should be private
* Should not extend prespecified classes, not implement prespecified interfaces and not contain prespecified annotations
* It may not have no argument constructor

Spring下的Bean可以理解为增强版的POJO.

<h6>Spring下配置Bean途径:</h6>

* XML中进行显式配置
* Java代码中显式配置
* 隐式的bean自动扫描和装配

<h6>1. 自动扫描和装配bean</h6>

Spring从两个角度来实现自动化装配:

* 组件声明: 声明Spring组件，即要创建的bean
* 组件扫描(component scaning): Spring自动发现应用上下文中所创建的bean
* 自动装配(autowiring): Spring自动满足bean之间的依赖

组件声明---使用@Component注解声明Spring组件

```java
// 组件类声明,并告诉Spring要为这个类创建bean
@Component
public class SgtPeppers implements CompactDisc {
    public void play() {
    }
}
```
@Component("自定义bean ID"),默认是类名首字母小写后的名称

组件扫描---使用@ComponentScan注解
```java
@Configuration
@ComponentScan
public class CDPlayerConfig {
}
```
@Configuration为Spring Java配置文件的注解，@ComponentScan默认扫描配置文件所在包，
可以使用@ComponentScan(basePackages="包名")或者@ComponentScan(basePackages={"包名1"，"包名2"})
@ComponentScan可以指定扫描类@ComponentScan(basePackageClasses={类名.class，类名.class})

组件扫描---使用xml配置
```
xmlns:context="http://www.springframework.org/schema/context"
<context:component-scan base-package="包名" />
```
组件自动装配---使用@Autowired注解
```java
@Component
public class CDPlayer implements MediaPlayer{
    private CompactDisc cd;
    
    @Autowired
    public CDPlayer(CompactDisc cd){
        this.cd = cd;
    }

    public void play() { }
}
```
* @Autowired注解是Spring中特有的，可以使用@Inject(来源于java依赖注入规范)代替
* @Autowired不仅可以在构造器上使用，还可以在set方法上使用，更一般可以在任意方法中使用
* @Autowired在无法找到满足依赖注入的bean时，将抛出异常。@Autowired(required=false)表明禁止
异常抛出，谨慎使用

自动扫描和装配缺点:

* 装配时满足注入依赖的类对象可能有多个
* 不能为第三方库添加@Component和@Autowired注释

<h6>2. Java代码装配Bean</h6>
&emsp;在进行显式配置时,JavaConfig是更好的方案,因为它更为强大、类型安全并且对重构友好。因为它就是Java代码,
就像应用程序中的其他Java代码一样。

创建配置类---JavaConfig
```java
@Configuration
public class CDPlayerConfig {

}
```
@Configuration注解表明这个类是一个配置类,该类应该包含在Spring应用上下文中如何创建bean的细节。

声明Bean---在JavaConfig中
```java
@Bean
public CompactDisc sgtPeppers(){
    return new SgtPeppers();
}
// 使用构造器实现依赖注入，生成bean
@Bean
public CDPlayer cdPlayer(CompactDisc compactDisc){
    return new CDPlayer(compactDisc);
}
```
* @Bean注解会告诉Spring这个方法将会返回一个对象,该对象要注册为Spring应用上下文中的bean。方法体中包含了最终产生bean实例的
逻辑
* @Bean声明使用方法名作为默认bean的ID,上例ID为sgtPeppers,使用@Bean(name="ID名")更改

<h6>3. XML装配Bean</h6>
&emsp;在xml中，beans为根元素，以此创建bean
```
<bean id="ID名" class="类名">
    <constructor-arg value/ref="字面量值/引用bean ID"></constructor-arg>
    <property name="变量名" value/ref="字面量值/引用bean ID"></property>
</bean>
```
* 构造器参数可以使用c命名空间
* 类的变量可以使用p命名空间

<h6>混合装配</h6>
Java代码混合装配

* JavaConfig中使用@ComponentScan实现组件自动扫描
* JavaConfig中使用@Import导入Java配置代码.@Import(类名.class)或@Import({类名.class,类名.class})
* JavaConfig中使用@ImportResource导入xml.@ImportResource("xml路径")

xml混合装配

* xml配置自动扫描
* xml使用`<bean class="JavaConfig类">`来导入Java代码配置
* xml使用`<import resource="xml路径">`来导入xml配置



[springModule]: images/springModule.png "springModule" { width:auto; max-width:90%}

